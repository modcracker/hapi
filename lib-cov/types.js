/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['types.js']) {
  _$jscoverage['types.js'] = [];
  _$jscoverage['types.js'][4] = 0;
  _$jscoverage['types.js'][5] = 0;
  _$jscoverage['types.js'][6] = 0;
  _$jscoverage['types.js'][13] = 0;
  _$jscoverage['types.js'][14] = 0;
  _$jscoverage['types.js'][17] = 0;
  _$jscoverage['types.js'][18] = 0;
  _$jscoverage['types.js'][19] = 0;
  _$jscoverage['types.js'][23] = 0;
  _$jscoverage['types.js'][25] = 0;
  _$jscoverage['types.js'][35] = 0;
  _$jscoverage['types.js'][37] = 0;
  _$jscoverage['types.js'][38] = 0;
  _$jscoverage['types.js'][42] = 0;
  _$jscoverage['types.js'][43] = 0;
  _$jscoverage['types.js'][44] = 0;
  _$jscoverage['types.js'][48] = 0;
  _$jscoverage['types.js'][49] = 0;
  _$jscoverage['types.js'][52] = 0;
  _$jscoverage['types.js'][63] = 0;
  _$jscoverage['types.js'][64] = 0;
  _$jscoverage['types.js'][65] = 0;
  _$jscoverage['types.js'][67] = 0;
  _$jscoverage['types.js'][68] = 0;
  _$jscoverage['types.js'][71] = 0;
  _$jscoverage['types.js'][75] = 0;
  _$jscoverage['types.js'][78] = 0;
  _$jscoverage['types.js'][88] = 0;
  _$jscoverage['types.js'][89] = 0;
  _$jscoverage['types.js'][90] = 0;
  _$jscoverage['types.js'][93] = 0;
  _$jscoverage['types.js'][102] = 0;
  _$jscoverage['types.js'][103] = 0;
  _$jscoverage['types.js'][104] = 0;
  _$jscoverage['types.js'][105] = 0;
  _$jscoverage['types.js'][107] = 0;
  _$jscoverage['types.js'][108] = 0;
  _$jscoverage['types.js'][109] = 0;
  _$jscoverage['types.js'][110] = 0;
  _$jscoverage['types.js'][114] = 0;
  _$jscoverage['types.js'][124] = 0;
  _$jscoverage['types.js'][125] = 0;
  _$jscoverage['types.js'][127] = 0;
  _$jscoverage['types.js'][128] = 0;
  _$jscoverage['types.js'][129] = 0;
  _$jscoverage['types.js'][130] = 0;
  _$jscoverage['types.js'][132] = 0;
  _$jscoverage['types.js'][135] = 0;
  _$jscoverage['types.js'][136] = 0;
  _$jscoverage['types.js'][139] = 0;
  _$jscoverage['types.js'][149] = 0;
  _$jscoverage['types.js'][151] = 0;
  _$jscoverage['types.js'][153] = 0;
  _$jscoverage['types.js'][154] = 0;
  _$jscoverage['types.js'][155] = 0;
  _$jscoverage['types.js'][156] = 0;
  _$jscoverage['types.js'][157] = 0;
  _$jscoverage['types.js'][158] = 0;
  _$jscoverage['types.js'][159] = 0;
  _$jscoverage['types.js'][162] = 0;
  _$jscoverage['types.js'][163] = 0;
  _$jscoverage['types.js'][164] = 0;
  _$jscoverage['types.js'][165] = 0;
  _$jscoverage['types.js'][166] = 0;
  _$jscoverage['types.js'][167] = 0;
  _$jscoverage['types.js'][168] = 0;
  _$jscoverage['types.js'][169] = 0;
  _$jscoverage['types.js'][170] = 0;
  _$jscoverage['types.js'][176] = 0;
  _$jscoverage['types.js'][177] = 0;
  _$jscoverage['types.js'][178] = 0;
  _$jscoverage['types.js'][180] = 0;
  _$jscoverage['types.js'][184] = 0;
  _$jscoverage['types.js'][192] = 0;
  _$jscoverage['types.js'][193] = 0;
  _$jscoverage['types.js'][194] = 0;
  _$jscoverage['types.js'][195] = 0;
  _$jscoverage['types.js'][198] = 0;
  _$jscoverage['types.js'][199] = 0;
  _$jscoverage['types.js'][202] = 0;
  _$jscoverage['types.js'][205] = 0;
  _$jscoverage['types.js'][206] = 0;
  _$jscoverage['types.js'][212] = 0;
  _$jscoverage['types.js'][213] = 0;
  _$jscoverage['types.js'][214] = 0;
  _$jscoverage['types.js'][219] = 0;
  _$jscoverage['types.js'][224] = 0;
}
_$jscoverage['types.js'][4]++;
var Utils = require("./utils");
_$jscoverage['types.js'][5]++;
var path = require("path");
_$jscoverage['types.js'][6]++;
var async = require("async");
_$jscoverage['types.js'][13]++;
function Types() {
  _$jscoverage['types.js'][14]++;
  this.registry = {};
  _$jscoverage['types.js'][17]++;
  this.mutatorAliases = ["set", "register"];
  _$jscoverage['types.js'][18]++;
  for (var i in this.mutatorAliases) {
    _$jscoverage['types.js'][19]++;
    Types.prototype[this.mutatorAliases[i]] = Types.prototype.get;
}
  _$jscoverage['types.js'][23]++;
  this.load(path.join(__dirname, "./type/"));
  _$jscoverage['types.js'][25]++;
  return this;
}
_$jscoverage['types.js'][35]++;
Types.prototype.isInvalidType = (function (name, baseObj) {
  _$jscoverage['types.js'][37]++;
  if (typeof name === "undefined" || name === null || name === "") {
    _$jscoverage['types.js'][38]++;
    return "The name of a Type cannot be undefined, null, or blank";
  }
  _$jscoverage['types.js'][42]++;
  var correctType = "function";
  _$jscoverage['types.js'][43]++;
  if (typeof baseObj !== correctType) {
    _$jscoverage['types.js'][44]++;
    return "Type " + name + " must be of type " + correctType + " (was " + typeof baseObj + ")";
  }
  _$jscoverage['types.js'][48]++;
  if (typeof baseObj().validate == "undefined" || baseObj().validate === null || typeof baseObj().validate !== "function") {
    _$jscoverage['types.js'][49]++;
    return "The '" + name + "' Type must provide a .validate() function";
  }
  _$jscoverage['types.js'][52]++;
  return null;
});
_$jscoverage['types.js'][63]++;
Types.prototype.get = (function (name, baseObj) {
  _$jscoverage['types.js'][64]++;
  if (typeof baseObj !== "undefined" && baseObj !== null) {
    _$jscoverage['types.js'][65]++;
    var err = this.isInvalidType(name, baseObj);
    _$jscoverage['types.js'][67]++;
    if (err) {
      _$jscoverage['types.js'][68]++;
      throw err;
    }
    _$jscoverage['types.js'][71]++;
    if (! Utils.DNE(this.registry[name])) {
    }
    _$jscoverage['types.js'][75]++;
    this.registry[name] = baseObj;
  }
  _$jscoverage['types.js'][78]++;
  return this.registry[name];
});
_$jscoverage['types.js'][88]++;
Types.prototype.unset = (function (name) {
  _$jscoverage['types.js'][89]++;
  if (typeof this.registry[name] !== "undefined") {
    _$jscoverage['types.js'][90]++;
    delete this.registry[name];
  }
  _$jscoverage['types.js'][93]++;
  return this;
});
_$jscoverage['types.js'][102]++;
Types.prototype.load = (function (cwd) {
  _$jscoverage['types.js'][103]++;
  var self = this;
  _$jscoverage['types.js'][104]++;
  Utils.File.walk(cwd, {includeOnly: [/.*\.js/], excludeOnly: ["base.js"]}, (function (err, files) {
  _$jscoverage['types.js'][105]++;
  if (err) {
    _$jscoverage['types.js'][105]++;
    throw err;
  }
  _$jscoverage['types.js'][107]++;
  for (var i in files) {
    _$jscoverage['types.js'][108]++;
    var p = files[i];
    _$jscoverage['types.js'][109]++;
    var presetType = require(p);
    _$jscoverage['types.js'][110]++;
    self.set(presetType.__name, presetType);
}
}));
  _$jscoverage['types.js'][114]++;
  return this;
});
_$jscoverage['types.js'][124]++;
Types.prototype.ensure = (function (typeStr, options) {
  _$jscoverage['types.js'][125]++;
  options = options || {};
  _$jscoverage['types.js'][127]++;
  if (typeof typeStr === "string") {
    _$jscoverage['types.js'][128]++;
    options.type = typeStr;
  }
  else {
    _$jscoverage['types.js'][129]++;
    if (typeof typeStr === "object") {
      _$jscoverage['types.js'][130]++;
      options = Utils.merge(options, typeStr);
    }
    else {
      _$jscoverage['types.js'][132]++;
      throw "Unexpected type passed to Types.ensure(type[, options]); expected";
    }
  }
  _$jscoverage['types.js'][135]++;
  if (options.type === null) {
    _$jscoverage['types.js'][136]++;
    options.type = "String";
  }
  _$jscoverage['types.js'][139]++;
  return options;
});
_$jscoverage['types.js'][149]++;
Types.prototype.validateCollection = (function (request, config, callback) {
  _$jscoverage['types.js'][151]++;
  var collection = request.query? Utils.clone(request.query): {};
  _$jscoverage['types.js'][153]++;
  var uri = config.path;
  _$jscoverage['types.js'][154]++;
  var rules = config.query || {};
  _$jscoverage['types.js'][155]++;
  var process = (rules instanceof Array)? this.validateDSL: this.validateNormal;
  _$jscoverage['types.js'][156]++;
  var requiredParams = {};
  _$jscoverage['types.js'][157]++;
  var missingParams;
  _$jscoverage['types.js'][158]++;
  var state = {};
  _$jscoverage['types.js'][159]++;
  var depGraph = {};
  _$jscoverage['types.js'][162]++;
  if (uri.indexOf(":") >= 0) {
    _$jscoverage['types.js'][163]++;
    var fragments = uri.split("/");
    _$jscoverage['types.js'][164]++;
    for (var f in fragments) {
      _$jscoverage['types.js'][165]++;
      var pathfrag = fragments[f];
      _$jscoverage['types.js'][166]++;
      if (pathfrag[0] == ":") {
        _$jscoverage['types.js'][167]++;
        var key = pathfrag.slice(1);
        _$jscoverage['types.js'][168]++;
        var val = request.params[key];
        _$jscoverage['types.js'][169]++;
        if (val !== null) {
          _$jscoverage['types.js'][170]++;
          collection[key] = val;
        }
      }
}
  }
  _$jscoverage['types.js'][176]++;
  for (var r in rules) {
    _$jscoverage['types.js'][177]++;
    if (rules.hasOwnProperty(r)) {
      _$jscoverage['types.js'][178]++;
      if (rules[r].required === true) {
        _$jscoverage['types.js'][180]++;
        requiredParams[r] = 1;
      }
      _$jscoverage['types.js'][184]++;
      if (! Utils.DNE(rules[i].group)) {
      }
    }
}
  _$jscoverage['types.js'][192]++;
  for (var i in collection) {
    _$jscoverage['types.js'][193]++;
    if (collection.hasOwnProperty(i)) {
      _$jscoverage['types.js'][194]++;
      if (typeof rules[i] !== "object") {
        _$jscoverage['types.js'][195]++;
        continue;
      }
      _$jscoverage['types.js'][198]++;
      if (rules[i].required === true) {
        _$jscoverage['types.js'][199]++;
        delete requiredParams[i];
      }
      _$jscoverage['types.js'][202]++;
      var err = this.get(rules[i].type)(collection[i]).validate();
      _$jscoverage['types.js'][205]++;
      if (err !== null) {
        _$jscoverage['types.js'][206]++;
        return callback(err);
      }
    }
}
  _$jscoverage['types.js'][212]++;
  missingParams = Object.keys(requiredParams);
  _$jscoverage['types.js'][213]++;
  if (missingParams.length !== 0) {
    _$jscoverage['types.js'][214]++;
    return callback("The following required parameters are missing: " + missingParams.toString());
  }
  _$jscoverage['types.js'][219]++;
  callback(null);
});
_$jscoverage['types.js'][224]++;
module.exports = new Types();
_$jscoverage['types.js'].source = ["/**"," * Module dependencies."," */","var Utils = require(\"./utils\");","var path = require(\"path\");","var async = require(\"async\");","","/**"," * Types constructor"," *"," * @api public"," */","function Types(){","  this.registry = {};","  ","  // Configure aliases for Types.get()","  this.mutatorAliases = [\"set\", \"register\"];","  for(var i in this.mutatorAliases){","    Types.prototype[this.mutatorAliases[i]] = Types.prototype.get;","  }","  ","  // Pre-load module-level default Type presets","  this.load(path.join(__dirname, \"./type/\"));","  ","  return this;","}","","/*"," * Returns error string if baseObj is invalid; else null"," *"," * @param {String} name"," * @param {Object} baseObj"," * @api public"," */","Types.prototype.isInvalidType = function(name, baseObj){","  // Must have a non-blank name","  if (typeof name === \"undefined\" || name === null || name === \"\"){","    return \"The name of a Type cannot be undefined, null, or blank\";","  }","  ","  // Must be an object","  var correctType = \"function\"; // or was it \"object\"?","  if (typeof baseObj !== correctType){","    return \"Type \" + name + \" must be of type \" + correctType + \" (was \" + typeof baseObj + \")\";","  }","  ","  // Must provide validate function","  if (typeof baseObj().validate == \"undefined\" || baseObj().validate === null || typeof baseObj().validate !== \"function\"){","    return \"The '\" + name + \"' Type must provide a .validate() function\";","  }","  ","  return null;","}","","/**"," * Get/Set types"," *"," * @param {String} name"," * @param {Object} baseObj"," * @return {Object|null} the baseObj for the given type (or null)"," * @api public"," */","Types.prototype.get = function(name, baseObj){","  if (typeof baseObj !== \"undefined\" &amp;&amp; baseObj !== null){","    var err = this.isInvalidType(name, baseObj);","    ","    if (err){","      throw err;","    }","    ","    if (!Utils.DNE(this.registry[name])){","      // TODO: Log.warn overwriting...","    }","    ","    this.registry[name] = baseObj;","  }","  ","  return this.registry[name];","}","","","/*"," * Unset a Type from registry"," *"," * @param {String} name"," * @api public"," */","Types.prototype.unset = function(name){","  if (typeof this.registry[name] !== \"undefined\") {","    delete this.registry[name];","  }","  ","  return this;","}","","/*"," * Load Type files for given path"," *"," * @param {String} cwd"," * @api public"," */","Types.prototype.load = function(cwd){","  var self = this;","  Utils.File.walk(cwd, {includeOnly: [/.*\\.js/], excludeOnly: [\"base.js\"]}, function(err, files){","    if (err) throw err;","    ","    for(var i in files){","      var p = files[i];","      var presetType = require(p);","      self.set(presetType.__name, presetType);","    }","  });","  ","  return this;","}","","/*"," * Hapi validateQuery interface (generates options in validate(options))"," *"," * @param {String|Object} typeStr String name of registered type to use or options object."," * @param {Object} options (optional)"," * @api public"," */","Types.prototype.ensure = function(typeStr, options){","  options = options || {};","  ","  if (typeof typeStr === \"string\"){","    options.type = typeStr;","  } else if (typeof typeStr === \"object\"){","    options = Utils.merge(options, typeStr);","  } else {","    throw \"Unexpected type passed to Types.ensure(type[, options]); expected\"","  }","  ","  if (options.type === null){","    options.type = \"String\"; // default to StringType","  }","  ","  return options;","}","","","/*"," *"," *"," *"," *"," */","Types.prototype.validateCollection = function(request, config, callback){","  // TODO: check that args are valid (perhaps do on server boot?)","  var collection = request.query ? Utils.clone(request.query) : {}; // TODO: parse route","  ","  var uri = config.path;","  var rules = config.query || {};","  var process = (rules instanceof Array) ? this.validateDSL : this.validateNormal;","  var requiredParams = {};","  var missingParams;","  var state = {}; // TODO: might not be necessary","  var depGraph = {}; // dependency Graph (maps any relationships between variables)","    ","  // Parse route/URI and treat as part of collection","  if (uri.indexOf(\":\") &gt;= 0){","    var fragments = uri.split(\"/\");","    for(var f in fragments){","      var pathfrag = fragments[f];","      if (pathfrag[0] == \":\"){","        var key = pathfrag.slice(1);","        var val = request.params[key];","        if (val !== null){","          collection[key] = val;","        }","      }","    }","  }","  ","  for(var r in rules){","    if (rules.hasOwnProperty(r)){","      if (rules[r].required === true){","        // requiredCount++;","        requiredParams[r] = 1;","      }","      ","      // TODO: populate depGraph with relationships","      if (!Utils.DNE(rules[i].group)){","        // TODO: determine which type of group","        // depGraph[\"&amp;\"][rules[i].group].push(i);","        // depGraph[\"|\"][rules[i].group].push(i);","      }","    }","  }","  ","  for(var i in collection){","    if (collection.hasOwnProperty(i)){","      if (typeof rules[i] !== \"object\"){","        continue; // No rules supplied =&gt; no validation, skip","      }","      ","      if (rules[i].required === true){","        delete requiredParams[i];","      }","      ","      var err = this.get(rules[i].type)(collection[i]).validate()","      // console.log(i, err)","      // var err = process(i, collection, rules, state, depGraph); // TODO: expand","      if (err !== null){","        return callback(err);","      }","    }","  }","  ","  // Report missing required params  ","  missingParams = Object.keys(requiredParams);","  if (missingParams.length !== 0){","    return callback(\"The following required parameters are missing: \" + missingParams.toString());","  }","  ","  // TODO: Report missing relationships","  ","  callback(null)","}","","","// Module exports","module.exports = new Types();"];
